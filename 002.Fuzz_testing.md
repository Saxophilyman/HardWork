Самое сложное - это понять о чём идёт речь))

Фазз-тестирование - это тестирование, которое применяется к программе, с целью выявить краевые случаи её работы. А если точнее выявить случаи при которой она не будет работать, хотя подразумевалось, что таких не имеется.
В подобных непрямолинейных инструментах вторым вопросом является как это всё применить.

-------------
Почему в программировании так мало простых и понятных гайдов. Открываешь статьи и они пестрят всевозможными ссылками, куча сложных терминов, множеством вариантов настроек. Почему нельзя просто подробно последовательно показать "кликай сюда, подсоединяй сюда, вот так, вот так и всё". С другой стороны вроде бы так все и стараются с делать. Но всё равно сложно и много нюансов. А мне не понятно. Сразу не понятно. И приходится разбираться.
Если говорить своими словами, то при исторической кафедре нам советовали ограничивать тему диплома. Она должна быть ограничена временными рамками, определена конкретная сфера и проблема в ней, задан контекст изучения, зафиксирована географическая область исследования. То есть максимизировать локальность.
Почему-то именно это пришло мне на ум, после ознакомления с хабровской статьёй, в которой нашлось более 50 ссылок на разного рода фаззеров.
Не смотря на примеры, было не до конца понятно как именно это использовать у себя в работе. 
Дело в том, что по сути фазеры, упрощая, это умный алгоритмический перебор входных данных и если мы будем тестировать всю программу целиком нам выйдет слишком дорого по ресурсам и времени.
Тестировать маленькие блоки кода - теряется сама ценность применения фаззеров. 

Один большой нюанс, что для более качественного результата стоит определять как корпус, так и оракулы. В каком-то роде делая обвязку и изолирование своего кода. А для этого ещё раз нужно разобраться и определить примеры.
Оракулы своего рода правила, которые позволяют фазеру "узнать" как правильно. Предполагается, что оракулы можно постепенно усиливать добавляя инварианты.
Наверное отдельным искусством, талантом, гениальностью стоит выделить умение разобраться в этих портянках вывода по результатам. Ещё с Prometheus заметил.
Как всегда на простых линейных примерах всё понятно. Но если брать что-то более сложное рабочее...
Имея полезный опыт полного стирания БД при сквозном тестировании с H2, нашёл предупреждение, что при полноценном запуске фаззеров на всём приложении для таких связок как Spring/HTTP/БД эффективность фаззеров падает, а чтобы всё не полетело и не переломалось нужно предусматривать режим песочницы, возможность восстановления системы, лимиты.
Выглядит логично, поэтому сам не пробовал. Тестировал проект autopark. Наилучшим способом определил для себя тестирование комплексных модулей. Выбрал Jazzer, само собой язык JAVA, время прогона по 2 минуты, определил 2 сида. Решил ограничиться прежде всего импортами csv.
Пришлось поковыряться с самой настройкой тестового метода. Со структурой входных данных, чтобы фаззер не байтами перебирал, а шёл по "значениям" и инвариантам. Но к своему удивлению пока ошибок обнаружено не было, возможно надо ещё глубще копать или как-то ещё настраивать.

Пока мой вывод следующий: тестирование всего приложения фаззингом представляется немыслимым, но в случае тестирования модулей серии csv, json, валидации, мапперов и подобного кажется просто уникальным инструментом.
В порядке продолжения оптимизации ЦС, насколько понимаю, что для фаззинга гораздо проще и удобнее, если метод разбит более структурно без сложных сложенных циклов и многократного ветвления. Ведь фаззер перебирает "ветки".
Нужно понимать, что делает твоя программа и грамотно определять что именно проверяется фаззером, а затем правильно настраивать фаззер. В общем нужно ещё практиковать и практиковать))


В любом случае здесь ярко проявляется фраза что тесты помогают избежать ошибок, но не гарантируют, что их нет.
