Задание 1: Снижаем цикломатическую сложность (ЦС).  
(мой комментарий)

**Пример №1**
- ЦС около 14
- Неструктурный код в одно полотно
- Циклы в циклах
- Множественное if else

```java
import java.util.*;
public class Level1 {    
        public static int[] WordSearch(int len, String s, String subs) {
        String[] text = s.split(" ", 0);
        ArrayList<String> list = new ArrayList<>();
        list.add(0, "");
        int indexForLIst = 0;
        int countLen = len;
        boolean newString = true;
        for (int index = 0; index < text.length; index++) {
            if (text[index].length() <= countLen) {
                if (newString) {
                    list.set(indexForLIst, list.get(indexForLIst) + text[index]);
                } else {
                    list.set(indexForLIst, list.get(indexForLIst) + " " + text[index]);
                }
                countLen -= text[index].length() + 1;
                newString = false;
            } else {
                countLen = len;
                newString = true;
                if (text[index].length() > len) {
                    indexForLIst++;
                    list.add(indexForLIst, "");
                    if (indexForLIst - 1 == 0 && list.get(0).isEmpty()) {
                        list.remove(indexForLIst);
                        indexForLIst--;
                    }
                    int indexOfLargeString = 0;
                    int endIndexOfLargeString = text[index].length();
                    while (indexOfLargeString <= text[index].length()) {
                        if (endIndexOfLargeString >= len) {
                            list.set(indexForLIst, text[index].substring(indexOfLargeString, indexOfLargeString + len));
                            indexForLIst++;
                            list.add(indexForLIst, "");
                        } else {
                            endIndexOfLargeString = indexOfLargeString + endIndexOfLargeString;
                            list.set(indexForLIst, text[index].substring(indexOfLargeString, endIndexOfLargeString) + "");
                        }
                        endIndexOfLargeString -= len;
                        indexOfLargeString += len;
                    }
                    countLen -= list.get(indexForLIst).length();
                } else {
                    index--;
                    indexForLIst++;
                    list.add(indexForLIst, "");
                }
                if (index + 1 == text.length && list.get(indexForLIst).isEmpty()) {
                    list.remove(indexForLIst);
                }
            }
        }
        int[] arr = new int[list.size()];
        for (int indexSearch = 0; indexSearch < list.size(); indexSearch++) {
            String[] searchText = list.get(indexSearch).split(" ");
            for (int inIndexSearchText = 0; inIndexSearchText < searchText.length; inIndexSearchText++) {
                if (searchText[inIndexSearchText].equals(subs)) {
                    arr[indexSearch] = 1;
                    break;
                }
            }
        }
        return arr;
    }
}
```

как я ни думал, полностью избавиться от if не представляю возможным, как и от применения циклов.
*Что получилось:*
- уйти от else,
- разбить структурно метод на вспомогательные методы,
- по возможности использовать streamApi
- попытаться уйти от проверки на null
Функция всё равно, кажется, довольно громоздкой и сложно вообще придумать и структурно создать что-то новое,
но она стала более модульной. Приходилось пересматривать код в несколько итераций, каждый раз что-то переделывая.
Сложнее при недостаточной практике использовать сами стримы, благо имеется много примеров в разных подходах.
Удобно, что при повторе подобных заданий можно как бы использовать блоки, чтобы строить способы обработки над строкой
Также добавил комментарии, чтобы в следующий раз не гадать что где и как работает
```java
import java.util.*;
import java.util.stream.*;

public class Level1 {
    public static int[] WordSearch(int len, String s, String subs) {
        // Уходим от проверки на null
        String nullCheck = Optional.ofNullable(s).orElse("");
        // Также делим текст на строки(внутри здесь будет вся алгоритмика)
        List<String> lines = divideIntoLines(len, nullCheck);
        //возвращаем массив целых чисел, содержащий 1 или 0
        return lines.stream()
                .mapToInt(line -> containsWord(line, subs) ? 1 : 0)//
                .toArray();
    }

    private static boolean containsWord(String line, String subs) {
        return Arrays.stream(line.split(" "))
                .anyMatch(subs::equals);
    }

    // Разбивка текста на строки фиксированной длины len
    private static List<String> divideIntoLines(int len, String s) {
        //порядок процедур
        //создаём класс для структуры
        StructureNeededLen newLines = new StructureNeededLen(len);
        //делим сам текст на единичные слова и применяем их к структуре "строк нужной длины"
        separationOfText(len, s).forEach(newLines::addWordInLine);
        //фиксируем результат
        return newLines.finish();
    }

    //заполняем структуру "строк определённой длины" единичными словами
    private static final class StructureNeededLen {
        //пытаемся закрыть возможные изменения состояний и создаём структуру
        private final int len;
        private final List<String> lines = new ArrayList<>();
        private final StringBuilder currentLine = new StringBuilder();

        private StructureNeededLen(int len) {
            this.len = len;
        }
        //алгоритм заполнения
        void addWordInLine(String currentWord) {
            int currentLength = currentLine.length();
            //строка пустая
            if (currentLength == 0) {
                currentLine.append(currentWord);
                return;
            }
            //можно добавить в строку ещё одно слово
            int space = 1;
            int needed = space + currentWord.length();
            if (currentLength + needed <= len) {
                currentLine.append(' ').append(currentWord);
                return;
            }
            // не помещается — "фиксируем" полученную строку и начинаем новую
            lines.add(currentLine.toString());
            currentLine.setLength(0);
            currentLine.append(currentWord);
        }
        //фиксируем результат
        List<String> finish() {
            if (currentLine.length() > 0) {
                lines.add(currentLine.toString());
            }
            return lines;
        }
    }

    // делаем из текста список "слов и фрагментов", длиной не больше len
    private static List<String> separationOfText(int len, String s) {
        return Arrays.stream(s.split(" "))
                .filter(word -> !word.isEmpty())
                .flatMap(word -> chunkWord(word, len).stream())
                .toList();
    }

    // если слова больше требуемой длины - разбиваем их
    private static List<String> chunkWord(String word, int len) {
        List<String> chunks = new ArrayList<>();
        int length = word.length();

        for (int start = 0; start < length; start += len) {
            int end = Math.min(start + len, length);
            chunks.add(word.substring(start, end));
        }

        return chunks;
    }        
}
```
**Коментарий о приёмах:**



**Пример №2**
-
-
-
-

```java
import java.util.*;

public class Level1 {
    public static String BigMinus(String s1, String s2) {

        StringBuilder resultSubtraction = new StringBuilder();
        StringBuilder upStringOfSubtraction = null;
        StringBuilder downStringOfSubtraction = null;
        StringBuilder dop = new StringBuilder("");

        for (int indexOfString = 0; indexOfString < s1.length(); indexOfString++) {
            if (s1.length() > s2.length()) {
                upStringOfSubtraction = new StringBuilder(s1);
                downStringOfSubtraction = new StringBuilder(s2);
                dop = new StringBuilder(upStringOfSubtraction.substring(0, upStringOfSubtraction.length() - downStringOfSubtraction.length()));
                break;
            } else if (s1.length() < s2.length()) {
                upStringOfSubtraction = new StringBuilder(s2);
                downStringOfSubtraction = new StringBuilder(s1);
                dop = new StringBuilder(upStringOfSubtraction.substring(0, upStringOfSubtraction.length() - downStringOfSubtraction.length()));
                break;
            } else if (s1.charAt(indexOfString) > s2.charAt(indexOfString)) {
                upStringOfSubtraction = new StringBuilder(s1.substring(indexOfString));
                downStringOfSubtraction = new StringBuilder(s2.substring(indexOfString));
                break;
            } else if (s1.charAt(indexOfString) < s2.charAt(indexOfString)) {
                upStringOfSubtraction = new StringBuilder(s2.substring(indexOfString));
                downStringOfSubtraction = new StringBuilder(s1.substring(indexOfString));
                break;
            }
              else if (s1.length() == s2.length() && s1.lastIndexOf(s2,s2.length()-1) !=-1 ){
                return String.valueOf(resultSubtraction.append("0"));
            }
        }

        assert upStringOfSubtraction != null;
        int minLength = Math.min(upStringOfSubtraction.length(), downStringOfSubtraction.length());
        int intCurrentSubtraction;
        int valueToCorrect = 0;

        for (int indexOfSubtraction = 1; indexOfSubtraction <= minLength; indexOfSubtraction++) {
            intCurrentSubtraction = (upStringOfSubtraction.charAt(upStringOfSubtraction.length() - indexOfSubtraction) - valueToCorrect) -
                    downStringOfSubtraction.charAt(downStringOfSubtraction.length() - indexOfSubtraction);
            if (intCurrentSubtraction < 0) {
                intCurrentSubtraction = 10 - Math.abs(intCurrentSubtraction);
                valueToCorrect = 1;
            } else {
                valueToCorrect = 0;
            }
            resultSubtraction.insert(0, intCurrentSubtraction);
        }

        int correctLength = 0;
        while (valueToCorrect != 0) {
            if (dop.charAt(dop.length() - 1) > 0 && dop.charAt(dop.length() - correctLength - 1) != '0') {
                dop.setCharAt(dop.length() - correctLength - 1, (char) (dop.charAt(dop.length() - correctLength - 1) - 1));
                valueToCorrect = 0;
            } else {
                dop.setCharAt(dop.length() - correctLength - 1, '9');
                correctLength++;
            }
        }
        resultSubtraction.insert(0, dop);
        if (resultSubtraction.charAt(0) > 0 && resultSubtraction.charAt(0) == '0') {
            resultSubtraction.deleteCharAt(0);
        }
        return String.valueOf(resultSubtraction);
    }
}
```


*Что получилось:*
-
-
-
-

```java

```


**Пример №3**
-
-
-
-

```java

```

*Что получилось:*
-
-
-
-

```java

```
