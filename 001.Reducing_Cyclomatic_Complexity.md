**Задание 1: Снижаем цикломатическую сложность (ЦС).** 
В определённом роде я был уже знаком с основными принципами снижения цикломатической сложности. И даже несколько пробовал от неё избавляться, например в курсе System Design. Но всё же возникало ощущение, что для меня значимость самого снижения цикломатической сложности является несколько опосредованной, по ходу дела, запомнил, да и ладно. Мне нравится, что в данном случае задание направлено именно на конкретный аспект и с повторными закреплениями. Я решил взять код "28 задач" и обратить более пристальное внимание, прежде всего, на  конструкции "if else". Уход от использования проверок на null и циклов был мне менее привычен и получался далеко не везде. Но сложнее всего следить было за возможностью использования полиморфизма, собственно  применён он и не был.

**Пример №1**
- ЦС около 14
- Неструктурный код в одно полотно
- Циклы в циклах
- Множественное if else

```java
import java.util.*;
public class Level1 {    
        public static int[] WordSearch(int len, String s, String subs) {
        String[] text = s.split(" ", 0);
        ArrayList<String> list = new ArrayList<>();
        list.add(0, "");
        int indexForLIst = 0;
        int countLen = len;
        boolean newString = true;
        for (int index = 0; index < text.length; index++) {
            if (text[index].length() <= countLen) {
                if (newString) {
                    list.set(indexForLIst, list.get(indexForLIst) + text[index]);
                } else {
                    list.set(indexForLIst, list.get(indexForLIst) + " " + text[index]);
                }
                countLen -= text[index].length() + 1;
                newString = false;
            } else {
                countLen = len;
                newString = true;
                if (text[index].length() > len) {
                    indexForLIst++;
                    list.add(indexForLIst, "");
                    if (indexForLIst - 1 == 0 && list.get(0).isEmpty()) {
                        list.remove(indexForLIst);
                        indexForLIst--;
                    }
                    int indexOfLargeString = 0;
                    int endIndexOfLargeString = text[index].length();
                    while (indexOfLargeString <= text[index].length()) {
                        if (endIndexOfLargeString >= len) {
                            list.set(indexForLIst, text[index].substring(indexOfLargeString, indexOfLargeString + len));
                            indexForLIst++;
                            list.add(indexForLIst, "");
                        } else {
                            endIndexOfLargeString = indexOfLargeString + endIndexOfLargeString;
                            list.set(indexForLIst, text[index].substring(indexOfLargeString, endIndexOfLargeString) + "");
                        }
                        endIndexOfLargeString -= len;
                        indexOfLargeString += len;
                    }
                    countLen -= list.get(indexForLIst).length();
                } else {
                    index--;
                    indexForLIst++;
                    list.add(indexForLIst, "");
                }
                if (index + 1 == text.length && list.get(indexForLIst).isEmpty()) {
                    list.remove(indexForLIst);
                }
            }
        }
        int[] arr = new int[list.size()];
        for (int indexSearch = 0; indexSearch < list.size(); indexSearch++) {
            String[] searchText = list.get(indexSearch).split(" ");
            for (int inIndexSearchText = 0; inIndexSearchText < searchText.length; inIndexSearchText++) {
                if (searchText[inIndexSearchText].equals(subs)) {
                    arr[indexSearch] = 1;
                    break;
                }
            }
        }
        return arr;
    }
}
```

как я ни думал, полностью избавиться от if не представляю возможным, как и от применения циклов.
*Что получилось:*
- уйти от else,
- разбить структурно метод на вспомогательные методы,
- по возможности использовать streamApi
- попытаться уйти от проверки на null
Функция всё равно, кажется, довольно громоздкой и сложно вообще придумать и структурно создать что-то новое,
но она стала более модульной. Приходилось пересматривать код в несколько итераций, каждый раз что-то переделывая.
Сложнее при недостаточной практике использовать сами стримы, благо имеется много примеров в разных подходах.
Удобно, что при повторе подобных заданий можно как бы использовать блоки, чтобы строить способы обработки над строкой.
Также добавил комментарии, чтобы в следующий раз не гадать что где и как работает.
```java
import java.util.*;
import java.util.stream.*;

public class Level1 {
    public static int[] WordSearch(int len, String s, String subs) {
        // Уходим от проверки на null
        String nullCheck = Optional.ofNullable(s).orElse("");
        // Также делим текст на строки(внутри здесь будет вся алгоритмика)
        List<String> lines = divideIntoLines(len, nullCheck);
        //возвращаем массив целых чисел, содержащий 1 или 0
        return lines.stream()
                .mapToInt(line -> containsWord(line, subs) ? 1 : 0)//
                .toArray();
    }

    private static boolean containsWord(String line, String subs) {
        return Arrays.stream(line.split(" "))
                .anyMatch(subs::equals);
    }

    // Разбивка текста на строки фиксированной длины len
    private static List<String> divideIntoLines(int len, String s) {
        //порядок процедур
        //создаём класс для структуры
        StructureNeededLen newLines = new StructureNeededLen(len);
        //делим сам текст на единичные слова и применяем их к структуре "строк нужной длины"
        separationOfText(len, s).forEach(newLines::addWordInLine);
        //фиксируем результат
        return newLines.finish();
    }

    //заполняем структуру "строк определённой длины" единичными словами
    private static final class StructureNeededLen {
        //пытаемся закрыть возможные изменения состояний и создаём структуру
        private final int len;
        private final List<String> lines = new ArrayList<>();
        private final StringBuilder currentLine = new StringBuilder();

        private StructureNeededLen(int len) {
            this.len = len;
        }
        //алгоритм заполнения
        void addWordInLine(String currentWord) {
            int currentLength = currentLine.length();
            //строка пустая
            if (currentLength == 0) {
                currentLine.append(currentWord);
                return;
            }
            //можно добавить в строку ещё одно слово
            int space = 1;
            int needed = space + currentWord.length();
            if (currentLength + needed <= len) {
                currentLine.append(' ').append(currentWord);
                return;
            }
            // не помещается — "фиксируем" полученную строку и начинаем новую
            lines.add(currentLine.toString());
            currentLine.setLength(0);
            currentLine.append(currentWord);
        }
        //фиксируем результат
        List<String> finish() {
            if (currentLine.length() > 0) {
                lines.add(currentLine.toString());
            }
            return lines;
        }
    }

    // делаем из текста список "слов и фрагментов", длиной не больше len
    private static List<String> separationOfText(int len, String s) {
        return Arrays.stream(s.split(" "))
                .filter(word -> !word.isEmpty())
                .flatMap(word -> chunkWord(word, len).stream())
                .toList();
    }

    // если слова больше требуемой длины - разбиваем их
    private static List<String> chunkWord(String word, int len) {
        List<String> chunks = new ArrayList<>();
        int length = word.length();

        for (int start = 0; start < length; start += len) {
            int end = Math.min(start + len, length);
            chunks.add(word.substring(start, end));
        }

        return chunks;
    }        
}
```



**Пример №2**
- ЦС около 12-14
- Неструктурный код в одно полотно
- Циклы в циклах
- Множественное if else

```java
import java.util.*;

public class Level1 {
    public static String BigMinus(String s1, String s2) {

        StringBuilder resultSubtraction = new StringBuilder();
        StringBuilder upStringOfSubtraction = null;
        StringBuilder downStringOfSubtraction = null;
        StringBuilder dop = new StringBuilder("");

        for (int indexOfString = 0; indexOfString < s1.length(); indexOfString++) {
            if (s1.length() > s2.length()) {
                upStringOfSubtraction = new StringBuilder(s1);
                downStringOfSubtraction = new StringBuilder(s2);
                dop = new StringBuilder(upStringOfSubtraction.substring(0, upStringOfSubtraction.length() - downStringOfSubtraction.length()));
                break;
            } else if (s1.length() < s2.length()) {
                upStringOfSubtraction = new StringBuilder(s2);
                downStringOfSubtraction = new StringBuilder(s1);
                dop = new StringBuilder(upStringOfSubtraction.substring(0, upStringOfSubtraction.length() - downStringOfSubtraction.length()));
                break;
            } else if (s1.charAt(indexOfString) > s2.charAt(indexOfString)) {
                upStringOfSubtraction = new StringBuilder(s1.substring(indexOfString));
                downStringOfSubtraction = new StringBuilder(s2.substring(indexOfString));
                break;
            } else if (s1.charAt(indexOfString) < s2.charAt(indexOfString)) {
                upStringOfSubtraction = new StringBuilder(s2.substring(indexOfString));
                downStringOfSubtraction = new StringBuilder(s1.substring(indexOfString));
                break;
            }
              else if (s1.length() == s2.length() && s1.lastIndexOf(s2,s2.length()-1) !=-1 ){
                return String.valueOf(resultSubtraction.append("0"));
            }
        }

        assert upStringOfSubtraction != null;
        int minLength = Math.min(upStringOfSubtraction.length(), downStringOfSubtraction.length());
        int intCurrentSubtraction;
        int valueToCorrect = 0;

        for (int indexOfSubtraction = 1; indexOfSubtraction <= minLength; indexOfSubtraction++) {
            intCurrentSubtraction = (upStringOfSubtraction.charAt(upStringOfSubtraction.length() - indexOfSubtraction) - valueToCorrect) -
                    downStringOfSubtraction.charAt(downStringOfSubtraction.length() - indexOfSubtraction);
            if (intCurrentSubtraction < 0) {
                intCurrentSubtraction = 10 - Math.abs(intCurrentSubtraction);
                valueToCorrect = 1;
            } else {
                valueToCorrect = 0;
            }
            resultSubtraction.insert(0, intCurrentSubtraction);
        }

        int correctLength = 0;
        while (valueToCorrect != 0) {
            if (dop.charAt(dop.length() - 1) > 0 && dop.charAt(dop.length() - correctLength - 1) != '0') {
                dop.setCharAt(dop.length() - correctLength - 1, (char) (dop.charAt(dop.length() - correctLength - 1) - 1));
                valueToCorrect = 0;
            } else {
                dop.setCharAt(dop.length() - correctLength - 1, '9');
                correctLength++;
            }
        }
        resultSubtraction.insert(0, dop);
        if (resultSubtraction.charAt(0) > 0 && resultSubtraction.charAt(0) == '0') {
            resultSubtraction.deleteCharAt(0);
        }
        return String.valueOf(resultSubtraction);
    }
}
```


*Что получилось:*
- Убрал лишние if else
- в какком-то смысле полностью переделанный код
- основной метод стал максимально простым, а операции разделены на методы 
Однако как полностью убрать и циклы и условия, не представляю возможным. Делить их мини-методы?


```java
package org.example;

public class BigMinusAfter {
    public static String BigMinus(String s1, String s2) {
        //Подготовим результат по длине для "верхней" строки
        int cmp = compareAbs(s1, s2);
        //тернарником определяем какая строка верхняя и вычитаем с выдачей результата
        return (cmp >= 0)
                ? subtractAbs(s1, s2)
                : subtractAbs(s2, s1);
    }

    //определяем значение -1/0/1, чтобы в тернарнике определить верхнюю строку и из неё произвести вычитание
    private static int compareAbs(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return Integer.compare(s1.length(), s2.length());
        }
        return s1.compareTo(s2);
    }

    //чистое вычитание по символам
    private static String subtractAbs(String s1, String s2) {
        char[] res = new char[s1.length()];

        int indexStr1 = s1.length() - 1;
        int indexStr2 = s2.length() - 1;
        int debt = 0;

        while (indexStr1 >= 0) {
            int currentA = s1.charAt(indexStr1) - '0' - debt;
            int currentB = (indexStr2 >= 0) ? (s2.charAt(indexStr2) - '0') : 0;

            if (currentA < currentB) {
                currentA += 10;
                debt = 1;
            } else {
                debt = 0;
            }

            int diff = currentA - currentB;
            res[indexStr1] = (char) ('0' + diff);

            indexStr1--;
            indexStr2--;
        }

        return deleteZero(res);
    }

    private static String deleteZero(char[] res) {
        int n = res.length;
        int firstNonZero = 0;
        while (firstNonZero < n - 1 && res[firstNonZero] == '0') {
            firstNonZero++;
        }
        return new String(res, firstNonZero, n - firstNonZero);
    }
}
```


**Пример №3**
- высокая ЦС около 18
- Неструктурный код в одно полотно
- Циклы в циклах
- Множественное if else

```java
import java.util.*;

public class Level1 {
    public static String TheRabbitsFoot(String s, boolean encode) {
        String[][] matrix;
        StringBuilder redString = new StringBuilder();
        int indexOfStr = 0;
        if (encode) {
            s = s.replaceAll("\\s", "");
        } else {
            s = s.replaceAll("\\s+", " ");
        }
        char[] stringCode = s.toCharArray();
        double n = Math.sqrt(s.length());
        int line = (int) n;
        int column;
        if (n > (int) n) {
            column = (int) n + 1;
        } else column = (int) n;
        if (s.length() > line * column) {
            line += 1;
        }
        String[] decrypt = s.split(" ");
        if (encode) {
            matrix = new String[line][column];
        } else {
            matrix = new String[decrypt[0].length()][decrypt.length];
        }

        for (int indexColumn = 0; indexColumn < matrix.length; indexColumn++) {
            for (int indexLine = 0; indexLine < matrix[0].length; indexLine++) {
                if (encode) {
                    if (indexOfStr < s.length()) {
                        matrix[indexColumn][indexLine] = String.valueOf(stringCode[indexOfStr]);
                    }
                } else {
                    if (indexOfStr < decrypt[indexColumn].length()) {
                        matrix[indexColumn][indexLine] = String.valueOf(decrypt[indexColumn].charAt(indexLine));
                    }
                }
                indexOfStr++;
            }
            if (!encode)
                indexOfStr = 0;
        }

        for (int indexLine = 0; indexLine < matrix[0].length; indexLine++) {
            for (int indexColumn = 0; indexColumn < matrix.length; indexColumn++) {
                if (matrix[indexColumn][indexLine] != null)
                    redString.append(matrix[indexColumn][indexLine]);
            }
            if (encode && indexLine != matrix[0].length - 1) {
                redString.append(" ");
            }
        }
        return String.valueOf(redString);
    }
}
```

*Что получилось:*
- здесь в продолжении постарался максимально разбить на мини-методы 
- ушел от вложенных if и от вложенных циклов
Здесь можно было бы применить полиморфизм, но серьёзного выигрыща от него особо нет.
Само итоговое количество кода получилось большим, чем было изначально,
но как отдельно разбитые операции - выглядит более логично и структурно.

```java
package org.example;

public class TheRabbitFoolAfter {
    public static String TheRabbitsFoot(String s, boolean encode) {
        String safe = (s == null) ? "" : s;
        return encode ? encodeRF(safe) : decodeRF(safe);
    }

    private static String encodeRF(String s) {
        //  убираем пробелы
        String compact = s.replaceAll("\\s", "");
        int length = compact.length();
        if (length == 0) {
            return "";
        }
        //решётка
        int[] rc = gridSize(length);
        int cols = rc[1];

        StringBuilder[] columnBuffers = initColumns(cols);
        // заполняем столбцы
        fillColumns(compact, columnBuffers);

        // склеиваем столбцы с пробелом
        return joinColumns(columnBuffers);
    }

    private static StringBuilder[] initColumns(int cols) {
        StringBuilder[] columnBuffers = new StringBuilder[cols];
        for (int c = 0; c < cols; c++) {
            columnBuffers[c] = new StringBuilder();
        }
        return columnBuffers;
    }

    // один проход по строке, без вложенных циклов
    private static void fillColumns(String text, StringBuilder[] columns) {
        int cols = columns.length;
        int length = text.length();

        for (int i = 0; i < length; i++) {
            int colIndex = i % cols;
            columns[colIndex].append(text.charAt(i));
        }
    }

    private static String joinColumns(StringBuilder[] columns) {
        StringBuilder result = new StringBuilder();
        for (int c = 0; c < columns.length; c++) {
            if (c > 0) {
                result.append(' ');
            }
            result.append(columns[c]);
        }
        return result.toString();
    }

    private static String decodeRF(String s) {
        String normalized = s.trim().replaceAll("\\s+", " ");
        if (normalized.isEmpty()) {
            return "";
        }
        // каждое слово столбец
        String[] cols = normalized.split(" ");
        int maxRows = maxColumnHeight(cols);

        return readByRows(cols, maxRows);
    }

    // максимальная высота столбцов
    private static int maxColumnHeight(String[] cols) {
        int max = 0;
        for (String col : cols) {
            int len = col.length();
            if (len > max) {
                max = len;
            }
        }
        return max;
    }

    // читаем матрицу по строкам
    private static String readByRows(String[] cols, int rows) {
        StringBuilder result = new StringBuilder();
        for (int r = 0; r < rows; r++) {
            appendRow(cols, r, result);
        }
        return result.toString();
    }

    private static void appendRow(String[] cols, int rowIndex, StringBuilder out) {
        for (String col : cols) {
            if (rowIndex < col.length()) {
                out.append(col.charAt(rowIndex));
            }
        }
    }

    private static int[] gridSize(int n) {
        double root = Math.sqrt(n);
        int rows = (int) root;
        int cols = (int) Math.ceil(root);
        if (rows * cols < n) {
            rows++;
        }
        return new int[]{rows, cols};
    }
}
```


В общем и целом задание оказалось достаточно сложным и хотелось бы больше показательных примеров, потому как не до конца понятно, а правильно ли ты делаешь в данном случае.
Сложно также разбирать свой старый код и конечно иногда имеется соблазн вообще всё полностью переделать с нуля. Отчасти некоторые вещи так и получаются.
Занимательно делать проходы по задаче по несколько раз и находить возможные улучшения. Но над самим навыком, особенно на более высоком уровне, чем просто убрать вложенные if else, нужно ещё работать и работать.
